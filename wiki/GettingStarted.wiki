#summary Getting started

= What are class loader leaks? =

In a J2EE environment, the container will create a separate class loader for each application. More precisely, in a full featured J2EE application server, there will be a separate class loader for each enterprise application (EAR), and each Web application (WAR) will also get its own class loader, which will be a child of the EAR class loader. Obviously, pure Servlet containers such as Tomcat which don't support EAR deployment will only create class loaders for WAR files.

Whenever an application is restarted or redeployed, the container will create a new class loader for the new application instance. It relies on the garbage collector to free the class loader of the stopped application instance. If for some reason after stopping an application a component outside of the application (i.e. in the JRE or in the server runtime) still holds a strong reference to the class loader of the stopped application instance, then the garbage collector will not remove the class loader from memory. This causes a particular type of memory leak called _class loader leak_.

In an environment where applications are frequently restarted or redeployed without restarting the entire server, a class loader leak will eventually result in an out of memory error (although it may require many application restarts before this actually occurs). With an Oracle JRE, the error message one gets in this case is typically `java.lang.OutOfMemoryError: PermGen space`. That is because class files are stored in the !PermGen space and this is typically the memory area that gets filled first (A class file can only be discarded from memory when the corresponding class loader is garbage collected). The error will be different on other JRE implementations because memory is organized differently, but the end result is the same.

= Costs and risks related to class loader leaks =

Addressing class loader leaks is challenging and costly:
  * They may go unnoticed for a long time. As noted above, depending on the application and on the container configuration (heap sizes), it is possible that a class loader leak triggers an out of memory error only after a very large number of application restarts. Since a change introducing a class loader leak will not result in an error immediately, it is not easy to identify which change caused the leak.
  * It is not easy to test an application for class loader leaks. One may attempt to do this by repeatedly restarting the application and observing the impact on memory utilization, or by checking if after stopping an application, the number of loaded classes in the JVM decreases. However, most real world applications have components that are only initialized lazily. This means that some class loader leaks will be triggered only after the application has processes a particular kind of request, which makes these approaches ineffective.
  * In general, identifying the root cause of a class loader leak requires to take a heap dump of the JVM and analyzing it with an appropriate tool such as [http://www.eclipse.org/mat/ Eclipse Memory Analyzer]. This is not only tedious but also requires a great deal of experience (especially when analyzing large dumps from acceptance or production systems).

Some people have argued that because eliminating class loader leaks is costly (and many class loader leaks only have a marginal impact), one should not bother about them and simply make sure that there is enough margin in memory allocation and to regularly restart the entire application server (or even require a restart of the application server every time an application is redeployed, at least on production systems).

Obviously this is a reasonable argument (at least in a business environment where decisions are based on economic arguments), but there are several things that should be taken into account before deciding to follow a strategy based on this argument:
  * It is based on the assumption that it is costly to identify and eliminate class loader leaks. As explained in the next section, the Arit project attempts to change this and reduce these costs by providing a tool to identify the most common types of class loader leaks.
  * Accepting applications with class loader leaks means accepting the latent risk of encountering an out of memory condition because the application server was not restarted in time and/or accepting the additional risk and cost caused by frequent application server restarts.
  * A class loader leak may be coupled to another issue that may represent a larger threat to the stability or operability of the environment than the leak itself. Keeping an eye on class loader leaks may therefore also help eliminating other, more important issues. Here are a couple of examples to illustrate this, including real world incidents:
    * In one case, an application exposing a custom MBean failed to unregister that MBean when stopping the application, causing a class loader leak. In addition to that, the application silently skipped registration of the MBean if the MBean already existed. The net result was that after an application restart, the registered custom MBean wouldn't allow to manage the currently running application instance, but a previously stopped one.
    * The documentation of the [JULHandler JUL plugin] describes an incident where an application unexpectedly registered an instance of `SLF4JBridgeHandler` into the JRE, not only causing a class loader leak, but also making the environment vulnerable to a deadlock which took down the server within minutes after its occurrence.
    * In some cases, the class loader leak is the a side effect of another more important memory leak that would eventually cause an out of memory error even without application restarts. This occurs if the application creates more and more strong references to distinct object instances (i.e. has a classic memory leak) and these references happen to be held directly or indirectly by something outside of the application (which then creates a class loader leak).
  * Not taking care of class loader leaks makes it harder to address classic memory leaks (which usually can't be simply ignored):
    * It is notoriously difficult to assess the memory footprint of a J2EE application. One way to get a reasonable estimate is to stop the application and observe the impact on heap usage. However, if the application also has a class loader leak, then this method is no longer effective.
    * Analyzing a classic memory leak becomes virtually impossible to do if the heap dump not only contains objects from the currently running instance of an application, but also from stopped ones (which occurs if the application has a class loader leak).

= How does Arit help with class loader leaks? =
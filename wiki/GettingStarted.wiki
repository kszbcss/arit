#summary Getting started

= What are class loader leaks? =

In a J2EE environment, the container will create a separate class loader for each application. More precisely, in a full featured J2EE application server, there will be a separate class loader for each enterprise application (EAR), and each Web application (WAR) will also get its own class loader, which will be a child of the EAR class loader. Obviously, pure Servlet containers such as Tomcat which don't support EAR deployment will only create class loaders for WAR files.

Whenever an application is restarted or redeployed, the container will create a new class loader for the new application instance. It relies on the garbage collector to free the class loader of the stopped application instance. If for some reason after stopping an application a component outside of the application (i.e. in the JRE or in the server runtime) still holds a strong reference to the class loader of the stopped application instance, then the garbage collector will not remove the class loader from memory. This causes a particular type of memory leak called _class loader leak_.

In an environment where applications are frequently restarted or redeployed without restarting the entire server, a class loader leak will eventually result in an out of memory error (although it may require many application restarts before this actually occurs). With an Oracle JRE, the error message one gets in this case is typically `java.lang.OutOfMemoryError: PermGen space`. That is because class files are stored in the !PermGen space and this is typically the memory area that gets filled first (A class file can only be discarded from memory when the corresponding class loader is garbage collected). The error will be different on other JRE implementations because memory is organized differently, but the end result is the same.

Addressing class loader leaks is challenging (and costly):
  * They may go unnoticed for a long time. As noted above, depending on the application and on the container configuration (heap sizes), it is possible that a class loader leak triggers an out of memory error only after a very large number of application restarts. Since a change introducing a class loader leak will not result in an error immediately, it is not easy to identify which change caused the leak.
  * It is not easy to test an application for class loader leaks. One may attempt to do this by repeatedly restarting the application and observing the impact on memory utilization, or by checking if after stopping an application, the number of loaded classes in the JVM decreases. However, most real world applications have components that are only initialized lazily. This means that some class loader leaks will be triggered only after the application has processes a particular kind of request, which makes these approaches ineffective.
  * In general, identifying the root cause of a class loader leak requires to take a heap dump of the JVM and analyzing it with an appropriate tool such as [http://www.eclipse.org/mat/ Eclipse Memory Analyzer]. This is not only tedious but also requires a great deal of experience (especially when analyzing large dumps from acceptance or production systems).

Some people have argued that because eliminating class loader leaks is costly (and many class loader leaks only have a marginal impact), one should not bother about them and simply make sure that there is enough margin in memory allocation and to regularly restart the entire application server (or even require a restart of the application server every time an application is redeployed, at least on production systems).

= How does Arit help with class loader leaks? =